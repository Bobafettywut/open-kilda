@startuml
title FLOW ping(verification) topology

control kilda.stats
control kilda.flow.status

participant Time
participant FlowFetcher
participant Neo4j

participant PingProducer
participant PingRouter
participant Blacklist
participant TimeoutManager
participant ResultManager
participant StatsProducer
participant FailReporter

control kilda.speaker
control kilda.ping

participant FL

control SW.source
control SW.dest

note right of FlowFetcher: must be 1\nin system

Time -> FlowFetcher: ping tick
activate FlowFetcher
FlowFetcher -> Neo4j: fetch all flow
activate Neo4j
Neo4j -> FlowFetcher: [flows]
deactivate Neo4j

note right of FlowFetcher: for each flow
FlowFetcher -> PingProducer: PingContext\n(field grouping)
deactivate FlowFetcher

activate PingProducer
note right of PingProducer: make ping request\n(source+dest)
PingProducer -> PingRouter: PingContext
deactivate PingProducer
activate PingRouter
PingRouter -> Blacklist: PingContext\n(field grouping)
deactivate PingRouter

activate Blacklist
alt blacklisted
Blacklist ->x Blacklist: drop request
else normal workflow
Blacklist -> PingRouter: PingContext
activate PingRouter
end
deactivate Blacklist

PingRouter -> TimeoutManager: PingContext\n(field grouping)
deactivate PingRouter

activate TimeoutManager
note right of TimeoutManager: scheduleTimeout for\npingId
TimeoutManager -> kilda.speaker: PingRequest

kilda.speaker -> FL: PingRequest
activate FL
note right of FL: make PingPackage
FL -> SW.source: PingPackage
deactivate FL

alt normal workflow
    SW.source -> SW.dest: PingPackage
    SW.dest -> FL: PingPackage
    activate FL
    note right of FL: measure flow\nlatency
    note right of FL: make PingResponse
    FL -> kilda.ping: PingResponse
    deactivate FL

    kilda.ping -> PingRouter: PingResponse
    PingRouter -> TimeoutManager: PingResponse\n(field grouping)
    note right of TimeoutManager: cancel timeout

    TimeoutManager -> ResultManager: PingContext\n(field grouping)
    activate ResultManager
    ResultManager -> FailReporter: flow-ok\n(field grouping)
    note right of FailReporter: reset fail flag
    ResultManager -> StatsProducer: PingContext\n(field grouping)
    deactivate ResultManager

    activate StatsProducer
    StatsProducer -> kilda.stats: flow ping stats
    deactivate StatsProducer

else lack of capabilities
    activate FL
    note right of FL: Sw.dest is not\ncapable to catch ping
    FL -> kilda.ping: ping response\n(lack of capabilities)
    deactivate FL
    kilda.ping -> PingRouter: ping response\n(lack of capabilities)
    PingRouter -> TimeoutManager: ping response\n(field grouping)
    note right of TimeoutManager: cancel timeout
    TimeoutManager -> ResultManager: PingContext\n(field grouping)
    activate ResultManager
    ResultManager -> FailReporter: pingContest\n(field grouping)
    note right of FailReporter: reset fail flag

    ResultManager -> ResultManager: log warning
    ResultManager -> PingRouter: PingContext
    deactivate ResultManager

    activate PingRouter
    PingRouter -> Blacklist: PingContext\n(field grouping)
    deactivate PingRouter
    activate Blacklist

    Blacklist ->x Blacklist: update blacklist
    deactivate Blacklist

else timeout
    Time -> TimeoutManager: X monotonic tick
    Time -> TimeoutManager: X + N monotonic tick
    note right of TimeoutManager: log error
    TimeoutManager -> ResultManager: PingContext\n(field grouping)
    deactivate TimeoutManager
    activate ResultManager

    ResultManager -> FailReporter: PingContext\n(field grouping)
    deactivate ResultManager
    activate FailReporter

    note right of FailReporter: set fail flag

    Time -> FailReporter: X monotonic tick
    Time -> FailReporter: X + M monotonic tick

    FailReporter -> kilda.flow.status: report flow failure

    deactivate FailReporter
end
deactivate TimeoutManager

@enduml
